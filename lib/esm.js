// Generated by KofuScript 0.0.3-alpha.2 
var present = console.log; 
// Generated by KofuScript 0.0.3-alpha.2 
var DEDENT, INDENT, pointToErrorLocation, Preprocessor, StringScanner, TERM, ws;
StringScanner = function () {
  function StringScanner(param$) {
    if (null == param$)
      param$ = '';
    this.str = param$;
    this.str = '' + this.str;
    this.pos = 0;
    this.lastMatch = {
      reset: function () {
        this.str = null;
        this.captures = [];
        return this;
      }
    }.reset();
  }
  StringScanner.prototype.bol = function () {
    return this.pos <= 0 || this.str[this.pos - 1] === '\n';
  };
  StringScanner.prototype.captures = function () {
    return this.lastMatch.captures;
  };
  StringScanner.prototype.check = function (pattern) {
    var matches;
    if (this.str.substr(this.pos).search(pattern) !== 0) {
      this.lastMatch.reset();
      return null;
    }
    matches = this.str.substr(this.pos).match(pattern);
    this.lastMatch.str = matches[0];
    this.lastMatch.captures = matches.slice(1);
    return this.lastMatch.str;
  };
  StringScanner.prototype.checkUntil = function (pattern) {
    var matches, patternPos;
    patternPos = this.str.substr(this.pos).search(pattern);
    if (patternPos < 0) {
      this.lastMatch.reset();
      return null;
    }
    matches = this.str.substr(this.pos + patternPos).match(pattern);
    this.lastMatch.captures = matches.slice(1);
    return this.lastMatch.str = this.str.substr(this.pos, patternPos) + matches[0];
  };
  StringScanner.prototype.clone = function () {
    var clone, prop, value;
    clone = new this.constructor(this.str);
    clone.pos = this.pos;
    clone.lastMatch = {};
    for (prop in this.lastMatch) {
      value = this.lastMatch[prop];
      clone.lastMatch[prop] = value;
    }
    return clone;
  };
  StringScanner.prototype.concat = function (str) {
    this.str += str;
    return this;
  };
  StringScanner.prototype.eos = function () {
    return this.pos === this.str.length;
  };
  StringScanner.prototype.exists = function (pattern) {
    var matches, patternPos;
    patternPos = this.str.substr(this.pos).search(pattern);
    if (patternPos < 0) {
      this.lastMatch.reset();
      return null;
    }
    matches = this.str.substr(this.pos + patternPos).match(pattern);
    this.lastMatch.str = matches[0];
    this.lastMatch.captures = matches.slice(1);
    return patternPos;
  };
  StringScanner.prototype.getch = function () {
    return this.scan(/./);
  };
  StringScanner.prototype.match = function () {
    return this.lastMatch.str;
  };
  StringScanner.prototype.matches = function (pattern) {
    this.check(pattern);
    return this.matchSize();
  };
  StringScanner.prototype.matched = function () {
    return null != this.lastMatch.str;
  };
  StringScanner.prototype.matchSize = function () {
    if (this.matched()) {
      return this.match().length;
    } else {
      return null;
    }
  };
  StringScanner.prototype.peek = function (len) {
    return this.str.substr(this.pos, len);
  };
  StringScanner.prototype.pointer = function () {
    return this.pos;
  };
  StringScanner.prototype.setPointer = function (pos) {
    pos = +pos;
    if (pos < 0)
      pos = 0;
    if (pos > this.str.length)
      pos = this.str.length;
    return this.pos = pos;
  };
  StringScanner.prototype.reset = function () {
    this.lastMatch.reset();
    this.pos = 0;
    return this;
  };
  StringScanner.prototype.rest = function () {
    return this.str.substr(this.pos);
  };
  StringScanner.prototype.scan = function (pattern) {
    var chk;
    chk = this.check(pattern);
    if (null != chk)
      this.pos += chk.length;
    return chk;
  };
  StringScanner.prototype.scanUntil = function (pattern) {
    var chk;
    chk = this.checkUntil(pattern);
    if (null != chk)
      this.pos += chk.length;
    return chk;
  };
  StringScanner.prototype.skip = function (pattern) {
    this.scan(pattern);
    return this.matchSize();
  };
  StringScanner.prototype.skipUntil = function (pattern) {
    this.scanUntil(pattern);
    return this.matchSize();
  };
  StringScanner.prototype.string = function () {
    return this.str;
  };
  StringScanner.prototype.terminate = function () {
    this.pos = this.str.length;
    this.lastMatch.reset();
    return this;
  };
  StringScanner.prototype.toString = function () {
    return '#<StringScanner ' + (this.eos() ? 'fin' : '' + this.pos + '/' + this.str.length + ' @ ' + (this.str.length > 8 ? '' + this.str.substr(0, 5) + '...' : this.str)) + '>';
  };
  return StringScanner;
}();
StringScanner.prototype.beginningOfLine = StringScanner.prototype.bol;
StringScanner.prototype.clear = StringScanner.prototype.terminate;
StringScanner.prototype.dup = StringScanner.prototype.clone;
StringScanner.prototype.endOfString = StringScanner.prototype.eos;
StringScanner.prototype.exist = StringScanner.prototype.exists;
StringScanner.prototype.getChar = StringScanner.prototype.getch;
StringScanner.prototype.position = StringScanner.prototype.pointer;
StringScanner.StringScanner = StringScanner;
pointToErrorLocation = function (source, line, column, numLinesOfContext) {
  var currentLineOffset, lines, numberedLines, padSize, postLines, preLines, startLine;
  if (null == numLinesOfContext)
    numLinesOfContext = 3;
  lines = source.split('\n');
  if (!lines[lines.length - 1])
    lines.pop();
  currentLineOffset = line - 1;
  startLine = currentLineOffset - numLinesOfContext;
  if (startLine < 0)
    startLine = 0;
  preLines = lines.slice(startLine, +currentLineOffset + 1 || 9e9);
  preLines[preLines.length - 1] = colourise('yellow', preLines[preLines.length - 1]);
  postLines = lines.slice(currentLineOffset + 1, +(currentLineOffset + numLinesOfContext) + 1 || 9e9);
  numberedLines = numberLines(cleanMarkers([].slice.call(preLines).concat([].slice.call(postLines)).join('\n')), startLine + 1).split('\n');
  preLines = numberedLines.slice(0, preLines.length);
  postLines = numberedLines.slice(preLines.length);
  column = cleanMarkers(('' + lines[currentLineOffset] + '\n').slice(0, column)).length;
  padSize = (currentLineOffset + 1 + postLines.length).toString(10).length;
  return [].slice.call(preLines).concat(['' + colourise('red', Array(padSize + 1).join('^')) + ' : ' + Array(column).join(' ') + colourise('red', '^')], [].slice.call(postLines)).join('\n');
};
this.Preprocessor = Preprocessor = function () {
  ws = '\\t\\x0B\\f\\r \\xA0\\u1680\\u180E\\u2000-\\u200A\\u202F\\u205F\\u3000\\uFEFF';
  INDENT = '\uefef';
  DEDENT = '\ueffe';
  TERM = '\uefff';
  function Preprocessor(param$) {
    if (null == param$)
      param$ = {};
    this.options = param$;
    this.preprocessed = '';
    this.base = null;
    this.indents = [];
    this.context = [];
  }
  Preprocessor.process = function (input, options) {
    if (null == options)
      options = {};
    return new Preprocessor(options).process(input);
  };
  Preprocessor.prototype.err = function (c) {
    var columns, context, lines, token;
    token = function () {
      switch (c) {
      case INDENT:
        return 'INDENT';
      case DEDENT:
        return 'DEDENT';
      case TERM:
        return 'TERM';
      default:
        return '"' + c.replace(/"/g, '\\"') + '"';
      }
    }.call(this);
    lines = this.ss.str.substr(0, this.ss.pos).split(/\n/) || [''];
    columns = null != lines[lines.length - 1] ? lines[lines.length - 1].length : 0;
    context = pointToErrorLocation(this.ss.str, lines.length, columns);
    throw new Error('Unexpected ' + token + '\n' + context);
  };
  Preprocessor.prototype.peek = function () {
    if (this.context.length) {
      return this.context[this.context.length - 1];
    } else {
      return null;
    }
  };
  Preprocessor.prototype.observe = function (c) {
    var top;
    top = this.peek();
    switch (c) {
    case '"""':
    case "'''":
    case '"':
    case "'":
    case '###':
    case '`':
    case '///':
    case '/':
      if (top === c) {
        this.context.pop();
      } else {
        this.context.push(c);
      }
      break;
    case INDENT:
    case '#':
    case '#{':
    case '[':
    case '(':
    case '{':
    case '\\':
    case 'regexp-[':
    case 'regexp-(':
    case 'regexp-{':
    case 'heregexp-#':
    case 'heregexp-[':
    case 'heregexp-(':
    case 'heregexp-{':
      this.context.push(c);
      break;
    case DEDENT:
      if (!(top === INDENT))
        this.err(c);
      this.indents.pop();
      this.context.pop();
      break;
    case '\n':
      if (!(top === '#' || top === 'heregexp-#'))
        this.err(c);
      this.context.pop();
      break;
    case ']':
      if (!(top === '[' || top === 'regexp-[' || top === 'heregexp-['))
        this.err(c);
      this.context.pop();
      break;
    case ')':
      if (!(top === '(' || top === 'regexp-(' || top === 'heregexp-('))
        this.err(c);
      this.context.pop();
      break;
    case '}':
      if (!(top === '#{' || top === '{' || top === 'regexp-{' || top === 'heregexp-{'))
        this.err(c);
      this.context.pop();
      break;
    case 'end-\\':
      if (!(top === '\\'))
        this.err(c);
      this.context.pop();
      break;
    default:
      throw new Error('undefined token observed: ' + c);
    }
    return this.context;
  };
  Preprocessor.prototype.p = function (s) {
    if (null != s)
      this.preprocessed = '' + this.preprocessed + s;
    return s;
  };
  Preprocessor.prototype.scan = function (r) {
    return this.p(this.ss.scan(r));
  };
  Preprocessor.prototype.consumeIndentation = function () {
    var context, indent, indentIndex, lineLen, lines, message;
    if (this.ss.bol() || this.scan(new RegExp('(?:[' + ws + ']*\\n)+'))) {
      this.scan(new RegExp('(?:[' + ws + ']*(\\#\\#?(?!\\#)[^\\n]*)?\\n)+'));
      if (null != this.base) {
        if (!(this.ss.eos() || null != this.scan(this.base))) {
          throw new Error('inconsistent base indentation');
        }
      } else {
        this.base = new RegExp('' + this.scan(new RegExp('[' + ws + ']*')) + '');
      }
      indentIndex = 0;
      while (indentIndex < this.indents.length) {
        indent = this.indents[indentIndex];
        if (this.ss.check(new RegExp('' + indent + ''))) {
          this.scan(new RegExp('' + indent + ''));
        } else if (this.ss.eos() || this.ss.check(new RegExp('[^' + ws + ']'))) {
          --indentIndex;
          this.p('' + DEDENT + TERM);
          this.observe(DEDENT);
        } else {
          lines = this.ss.str.substr(0, this.ss.pos).split(/\n/) || [''];
          message = 'Syntax error on line ' + lines.length + ': indentation is ambiguous';
          lineLen = this.indents.reduce(function (l, r) {
            return l + r.length;
          }, 0);
          context = pointToErrorLocation(this.ss.str, lines.length, lineLen);
          throw new Error('' + message + '\n' + context);
        }
        ++indentIndex;
      }
      if (this.ss.check(new RegExp('[' + ws + ']+[^' + ws + '#]'))) {
        this.indents.push(this.scan(new RegExp('[' + ws + ']+')));
        this.p(INDENT);
        return this.observe(INDENT);
      }
    }
  };
  Preprocessor.prototype.introduceContext = function () {
    var impliedRegexp, lastChar, pos, spaceBefore, tok;
    if (tok = this.scan(/"""|'''|\/\/\/|###|["'`#[({\\]/)) {
      return this.observe(tok);
    } else if (tok = this.scan(/\//)) {
      pos = this.ss.position();
      if (pos > 1) {
        lastChar = this.ss.string()[pos - 2];
        spaceBefore = new RegExp('[' + ws + ']').test(lastChar);
        impliedRegexp = /[;,=><*%^&|[(+!~-]/.test(lastChar);
      }
      if (pos === 1 || impliedRegexp || spaceBefore && !this.ss.check(new RegExp('[' + ws + '=]')) && this.ss.check(/[^\r\n]*\//))
        return this.observe('/');
    }
  };
  Preprocessor.prototype.process = function (input) {
    var tok;
    if (this.options.literate)
      input = input.replace(/^( {0,3}\S)/gm, '    #$1');
    this.ss = new StringScanner(input);
    while (!this.ss.eos()) {
      switch (this.peek()) {
      case null:
      case INDENT:
        this.consumeIndentation();
        this.scan(/[^\n'"\\\/#`[(){}\]]+/);
        if (this.ss.check(/[})\]]/)) {
          while (this.peek() === INDENT) {
            this.p('' + DEDENT + TERM);
            this.observe(DEDENT);
          }
          this.observe(this.scan(/[})\]]/));
        } else {
          this.introduceContext();
        }
        break;
      case '#{':
      case '{':
        this.scan(/[^\n'"\\\/#`[({}]+/);
        if (tok = this.scan(/\}/)) {
          this.observe(tok);
        } else {
          this.consumeIndentation();
          this.introduceContext();
        }
        break;
      case '[':
        this.scan(/[^\n'"\\\/#`[({\]]+/);
        if (tok = this.scan(/\]/)) {
          this.observe(tok);
        } else {
          this.consumeIndentation();
          this.introduceContext();
        }
        break;
      case '(':
        this.scan(/[^\n'"\\\/#`[({)]+/);
        if (tok = this.scan(/\)/)) {
          this.observe(tok);
        } else {
          this.consumeIndentation();
          this.introduceContext();
        }
        break;
      case '\\':
        if (this.scan(/[\s\S]/))
          this.observe('end-\\');
        break;
      case '"""':
        this.scan(/(?:[^"#\\]+|""?(?!")|#(?!{)|\\.)+/);
        this.ss.scan(/\\\n/);
        if (tok = this.scan(/#{|"""/)) {
          this.observe(tok);
        } else if (tok = this.scan(/#{|"""/)) {
          this.observe(tok);
        }
        break;
      case '"':
        this.scan(/(?:[^"#\\]+|#(?!{)|\\.)+/);
        this.ss.scan(/\\\n/);
        if (tok = this.scan(/#{|"/))
          this.observe(tok);
        break;
      case "'''":
        this.scan(/(?:[^'\\]+|''?(?!')|\\.)+/);
        this.ss.scan(/\\\n/);
        if (tok = this.scan(/'''/))
          this.observe(tok);
        break;
      case "'":
        this.scan(/(?:[^'\\]+|\\.)+/);
        this.ss.scan(/\\\n/);
        if (tok = this.scan(/'/))
          this.observe(tok);
        break;
      case '###':
        this.scan(/(?:[^#]+|##?(?!#))+/);
        if (tok = this.scan(/###/))
          this.observe(tok);
        break;
      case '#':
        this.scan(/[^\n]+/);
        if (tok = this.scan(/\n/))
          this.observe(tok);
        break;
      case '`':
        this.scan(/[^`]+/);
        if (tok = this.scan(/`/))
          this.observe(tok);
        break;
      case '///':
        this.scan(/(?:[^[/#\\]+|\/\/?(?!\/)|\\.)+/);
        if (tok = this.scan(/#{|\/\/\/|\\/)) {
          this.observe(tok);
        } else if (this.ss.scan(/#/)) {
          this.observe('heregexp-#');
        } else if (tok = this.scan(/[\[]/)) {
          this.observe('heregexp-' + tok);
        }
        break;
      case 'heregexp-[':
        this.scan(/(?:[^\]\/\\]+|\/\/?(?!\/))+/);
        if (tok = this.scan(/[\]\\]|#{|\/\/\//))
          this.observe(tok);
        break;
      case 'heregexp-#':
        this.ss.scan(/(?:[^\n/]+|\/\/?(?!\/))+/);
        if (tok = this.scan(/\n|\/\/\//))
          this.observe(tok);
        break;
      case '/':
        this.scan(/[^[/\\]+/);
        if (tok = this.scan(/[\/\\]/)) {
          this.observe(tok);
        } else if (tok = this.scan(/\[/)) {
          this.observe('regexp-' + tok);
        }
        break;
      case 'regexp-[':
        this.scan(/[^\]\\]+/);
        if (tok = this.scan(/[\]\\]/))
          this.observe(tok);
      }
    }
    this.scan(new RegExp('[' + ws + '\\n]*$'));
    while (this.context.length) {
      switch (this.peek()) {
      case INDENT:
        this.p('' + DEDENT + TERM);
        this.observe(DEDENT);
        break;
      case '#':
        this.p('\n');
        this.observe('\n');
        break;
      default:
        throw new Error('Unclosed "' + this.peek().replace(/"/g, '\\"') + '" at EOF');
      }
    }
    return this.preprocessed;
  };
  return Preprocessor;
}();
